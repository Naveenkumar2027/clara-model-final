[
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "191ca279-f45a-4142-90cd-465fbd5396f8",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC001-health check endpoint should return server status ok",
    "description": "Verify that the GET /healthz endpoint returns a 200 status code with a JSON body containing { status: 'ok' } indicating the server is healthy.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_health_check_endpoint_returns_status_ok():\n    url = f\"{BASE_URL}/healthz\"\n    try:\n        response = requests.get(url, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        json_data = response.json()\n        assert isinstance(json_data, dict), \"Response is not a JSON object\"\n        assert json_data.get(\"status\") == \"ok\", f\"Expected JSON key 'status' to be 'ok' but got {json_data.get('status')}\"\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\ntest_health_check_endpoint_returns_status_ok()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.039Z",
    "modified": "2025-11-07T04:20:22.399Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "6f5f00c0-261f-487a-80f8-6fd3e751ac80",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC002-staff login should authenticate and return jwt tokens",
    "description": "Test the POST /api/auth/login endpoint with valid email and password to ensure it returns a 200 status code with a JSON response containing a JWT token, refreshToken, and user object.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\ndef test_staff_login_should_authenticate_and_return_jwt_tokens():\n    url = BASE_URL + LOGIN_ENDPOINT\n    # Use valid test credentials for login\n    payload = {\n        \"email\": \"valid.staff@example.com\",\n        \"password\": \"ValidPassword123!\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not in JSON format\"\n\n    assert \"token\" in data, \"Response JSON missing 'token'\"\n    assert isinstance(data[\"token\"], str) and len(data[\"token\"]) > 0, \"'token' should be a non-empty string\"\n\n    assert \"refreshToken\" in data, \"Response JSON missing 'refreshToken'\"\n    assert isinstance(data[\"refreshToken\"], str) and len(data[\"refreshToken\"]) > 0, \"'refreshToken' should be a non-empty string\"\n\n    assert \"user\" in data, \"Response JSON missing 'user'\"\n    assert isinstance(data[\"user\"], dict) and len(data[\"user\"]) > 0, \"'user' should be a non-empty object\"\n\ntest_staff_login_should_authenticate_and_return_jwt_tokens()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.047Z",
    "modified": "2025-11-07T04:20:23.686Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "0fada881-f3ff-49d1-a0bc-ff679e9cede3",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC003-refresh token endpoint should issue new access token",
    "description": "Test the POST /api/auth/refresh-token endpoint with a valid refreshToken to verify it returns a 200 status code and issues a new access token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_refresh_token_endpoint_should_issue_new_access_token():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    refresh_url = f\"{BASE_URL}/api/auth/refresh-token\"\n    login_payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    try:\n        # Step 1: Authenticate and get refreshToken\n        login_resp = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        refresh_token = login_data.get(\"refreshToken\")\n        assert isinstance(refresh_token, str) and refresh_token, \"refreshToken missing or invalid in login response\"\n\n        # Step 2: Use refreshToken to get new access token\n        refresh_payload = {\n            \"refreshToken\": refresh_token\n        }\n        refresh_resp = requests.post(refresh_url, json=refresh_payload, timeout=TIMEOUT)\n        assert refresh_resp.status_code == 200, f\"Refresh token request failed with status {refresh_resp.status_code}\"\n\n        # Validate response contains a new token (access token)\n        refresh_data = refresh_resp.json()\n        # We expect a new access token in the response. The PRD description lacks explicit schema\n        # for the refresh response body, so we check for presence of a string token.\n        access_token = refresh_data.get(\"token\") or refresh_data.get(\"accessToken\")\n        assert isinstance(access_token, str) and access_token, \"New access token missing or invalid in refresh response\"\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_refresh_token_endpoint_should_issue_new_access_token()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.052Z",
    "modified": "2025-11-07T04:20:30.952Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "5baaccac-f033-48d8-867b-5b13f691516e",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC004-initiate video call should create call and return call id and status",
    "description": "Verify that POST /api/v1/calls with required parameters initiates a video call, returning 200 status with callId and status (ringing or initiated). Also test 503 response when no staff is available.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Dummy staff credentials for authentication (to be replaced with valid test credentials)\nSTAFF_EMAIL = \"staff@example.com\"\nSTAFF_PASSWORD = \"TestPassword123!\"\n\ndef login():\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\n        \"email\": STAFF_EMAIL,\n        \"password\": STAFF_PASSWORD\n    }\n    response = requests.post(url, json=payload, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"token\" in data and isinstance(data[\"token\"], str)\n    assert \"refreshToken\" in data and isinstance(data[\"refreshToken\"], str)\n    assert \"user\" in data and isinstance(data[\"user\"], dict)\n    return data[\"token\"]\n\ndef get_available_staff(token, org_id=None, skills=None):\n    url = f\"{BASE_URL}/api/v1/staff/availability\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    params = {}\n    if org_id is not None:\n        params[\"orgId\"] = org_id\n    if skills is not None:\n        if isinstance(skills, list):\n            params[\"skills\"] = \",\".join(skills)\n        else:\n            params[\"skills\"] = skills\n    response = requests.get(url, headers=headers, params=params, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    assert \"staff\" in data and isinstance(data[\"staff\"], list)\n    return data[\"staff\"]\n\ndef initiate_call(token, payload):\n    url = f\"{BASE_URL}/api/v1/calls\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef delete_call(token, call_id):\n    # No delete endpoint documented for call resource.\n    # Try to cancel or end call to cleanup.\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    try:\n        cancel_url = f\"{BASE_URL}/api/v1/calls/{call_id}/cancel\"\n        resp = requests.post(cancel_url, headers=headers, timeout=TIMEOUT)\n        if resp.status_code == 200:\n            return\n    except Exception:\n        pass\n    try:\n        end_url = f\"{BASE_URL}/api/v1/calls/{call_id}/end\"\n        resp = requests.post(end_url, headers=headers, timeout=TIMEOUT)\n        if resp.status_code == 200:\n            return\n    except Exception:\n        pass\n    # No documented way to forcibly delete a call\n\ndef test_TC004_initiate_video_call_should_create_call_and_return_call_id_and_status():\n    \"\"\"\n    Verify POST /api/v1/calls initiates a video call returning 200 with callId and status.\n    Verify 503 response when no staff is available.\n    Also validate JWT auth, voice recognition independent operation, and WebRTC aspects indirectly via API.\n    \"\"\"\n    token = login()\n\n    # Optional: Check staff availability before initiating call to attempt a successful call\n    staff_list = get_available_staff(token)\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Prepare a call payload with minimal required parameter clientId\n    # and optionally include orgId and targetStaffId if available from staff_list\n    client_id = \"test-client-123\"\n    org_id = None\n    target_staff_id = None\n    if staff_list:\n        # Pick the first available staff's id if exists and if 'id' field present, else fallback None\n        s = staff_list[0]\n        if isinstance(s, dict):\n            target_staff_id = s.get(\"id\") or s.get(\"staffId\") or None\n            org_id = s.get(\"orgId\") or None\n\n    payload = {\n        \"clientId\": client_id\n    }\n    if org_id:\n        payload[\"orgId\"] = org_id\n    if target_staff_id:\n        payload[\"targetStaffId\"] = target_staff_id\n    else:\n        # Not required by spec, but adding to try exact routing\n        payload[\"targetStaffId\"] = \"nonexistent-staff-id\"\n\n    call_id = None\n    try:\n        # Initiate call, expecting either 200 or 503\n        response = initiate_call(token, payload)\n        \n        if response.status_code == 200:\n            data = response.json()\n            assert \"callId\" in data and isinstance(data[\"callId\"], str) and data[\"callId\"]\n            assert \"status\" in data and data[\"status\"] in (\"ringing\", \"initiated\")\n            call_id = data[\"callId\"]\n            # Additional check: Try to GET call details using callId as sanity check of API endpoint\n            call_details_url = f\"{BASE_URL}/api/v1/calls/{call_id}\"\n            resp_call_details = requests.get(call_details_url, headers={\"Authorization\": f\"Bearer {token}\"}, timeout=TIMEOUT)\n            assert resp_call_details.status_code == 200\n            json_cd = resp_call_details.json()\n            assert isinstance(json_cd, dict)\n            assert \"callId\" in json_cd and json_cd[\"callId\"] == call_id\n\n        elif response.status_code == 503:\n            # No staff available response - valid error case\n            # Response body may be empty or have error message, accept either\n            try:\n                data = response.json()\n                assert isinstance(data, dict)\n            except Exception:\n                # No JSON body - acceptable in 503 error\n                pass\n        else:\n            # Unexpected status code - fail test\n            assert False, f\"Unexpected status code {response.status_code} returned\"\n    finally:\n        # Cleanup: cancel or end call if initiated\n        if call_id:\n            delete_call(token, call_id)\n\n\ntest_TC004_initiate_video_call_should_create_call_and_return_call_id_and_status()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.057Z",
    "modified": "2025-11-07T04:20:34.510Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "4097eae1-3921-467e-b7a0-0115ee64d900",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC005-accept call should succeed only if call is ringing",
    "description": "Test POST /api/v1/calls/{callId}/accept to accept a call only if it is in ringing state. Verify 200 on success and 409 if call is already accepted or not ringing.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:8080\"\nLOGIN_EMAIL = \"staff@example.com\"\nLOGIN_PASSWORD = \"SecurePass123!\"\n\ndef test_accept_call_should_succeed_only_if_call_is_ringing():\n    # Authenticate and get JWT token\n    auth_url = f\"{BASE_URL}/api/auth/login\"\n    auth_payload = {\"email\": LOGIN_EMAIL, \"password\": LOGIN_PASSWORD}\n    try:\n        auth_resp = requests.post(auth_url, json=auth_payload, timeout=30)\n        auth_resp.raise_for_status()\n        auth_data = auth_resp.json()\n        token = auth_data.get(\"token\")\n        assert token, \"Authentication token not received\"\n    except RequestException as e:\n        raise AssertionError(f\"Authentication failed: {str(e)}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 1: Initiate a call to get a callId with ringing status\n    calls_url = f\"{BASE_URL}/api/v1/calls\"\n    # Using dummy valid clientId, optional fields can be added if needed for test environment\n    call_payload = {\n        \"clientId\": \"test-client-123\"\n    }\n\n    call_id = None\n    try:\n        call_resp = requests.post(calls_url, json=call_payload, headers=headers, timeout=30)\n        call_resp.raise_for_status()\n        call_data = call_resp.json()\n        call_id = call_data.get(\"callId\")\n        call_status = call_data.get(\"status\")\n        assert call_id is not None, \"callId not returned\"\n    except RequestException as e:\n        raise AssertionError(f\"Failed to initiate call: {str(e)}\")\n\n    try:\n        # Verify we have a call in ringing or initiated state\n        # Only accept if in \"ringing\" state per test description\n        # If not ringing, try to fetch call details to assert status or fail test accordingly\n\n        # Get call details\n        call_details_url = f\"{BASE_URL}/api/v1/calls/{call_id}\"\n        details_resp = requests.get(call_details_url, headers=headers, timeout=30)\n        details_resp.raise_for_status()\n        details_data = details_resp.json()\n        call_current_status = details_data.get(\"status\") or call_status\n\n        # Prepare accept call URL\n        accept_url = f\"{BASE_URL}/api/v1/calls/{call_id}/accept\"\n\n        if call_current_status == \"ringing\":\n            # Accept call - expect 200\n            accept_resp = requests.post(accept_url, headers=headers, timeout=30)\n            assert accept_resp.status_code == 200, f\"Expected 200 for accepting ringing call, got {accept_resp.status_code}\"\n        else:\n            # Accept call when not ringing - expect 409 conflict\n            accept_resp = requests.post(accept_url, headers=headers, timeout=30)\n            assert accept_resp.status_code == 409, f\"Expected 409 for accepting non-ringing call, got {accept_resp.status_code}\"\n\n            # Also test accepting again if already accepted (edge case)\n            if call_current_status == \"accepted\" or accept_resp.status_code == 200:\n                second_accept_resp = requests.post(accept_url, headers=headers, timeout=30)\n                assert second_accept_resp.status_code == 409, f\"Expected 409 when accepting a call already accepted, got {second_accept_resp.status_code}\"\n\n    finally:\n        # Clean up: end the call\n        if call_id:\n            try:\n                end_url = f\"{BASE_URL}/api/v1/calls/{call_id}/end\"\n                end_resp = requests.post(end_url, headers=headers, timeout=30)\n                assert end_resp.status_code == 200\n            except Exception:\n                pass  # Suppress any exception in cleanup\n\ntest_accept_call_should_succeed_only_if_call_is_ringing()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 36, in test_accept_call_should_succeed_only_if_call_is_ringing\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 503 Server Error: Service Unavailable for url: http://localhost:8080/api/v1/calls\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 42, in test_accept_call_should_succeed_only_if_call_is_ringing\nAssertionError: Failed to initiate call: 503 Server Error: Service Unavailable for url: http://localhost:8080/api/v1/calls\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.062Z",
    "modified": "2025-11-07T04:20:39.368Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "3a7d6e86-d0da-4241-815e-a74e83e97214",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC006-decline call should mark call as declined with reason",
    "description": "Verify POST /api/v1/calls/{callId}/decline marks the call as declined and accepts an optional reason in the request body, returning 200 status.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Provide valid staff credentials here for authentication\nSTAFF_EMAIL = \"staff@example.com\"\nSTAFF_PASSWORD = \"correct_password\"\n\n\ndef authenticate():\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\"email\": STAFF_EMAIL, \"password\": STAFF_PASSWORD}\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    token = data.get(\"token\")\n    assert token is not None, \"Authentication token not found in response\"\n    return token\n\n\ndef initiate_call(token):\n    url = f\"{BASE_URL}/api/v1/calls\"\n    # Using minimal required clientId. Adjust as needed.\n    # Assuming clientId is the staff user id or some preset test client id\n    payload = {\n        \"clientId\": \"test-client-001\",\n        \"reason\": \"Test call for decline functionality\"\n    }\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    if resp.status_code == 503:\n        # No available staff, cannot proceed\n        raise RuntimeError(\"No available staff to accept calls, cannot initiate call for testing decline\")\n    resp.raise_for_status()\n    data = resp.json()\n    call_id = data.get(\"callId\")\n    status = data.get(\"status\")\n    assert call_id is not None, \"callId missing in initiate call response\"\n    assert status in (\"ringing\", \"initiated\"), \"Unexpected call status\"\n    return call_id\n\n\ndef get_call_details(token, call_id):\n    url = f\"{BASE_URL}/api/v1/calls/{call_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef decline_call(token, call_id, reason=None):\n    url = f\"{BASE_URL}/api/v1/calls/{call_id}/decline\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {} if reason is None else {\"reason\": reason}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp\n\n\ndef cancel_call(token, call_id):\n    url = f\"{BASE_URL}/api/v1/calls/{call_id}/cancel\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp\n\n\ndef test_decline_call_should_mark_call_as_declined_with_reason():\n    token = authenticate()\n    call_id = None\n    try:\n        call_id = initiate_call(token)\n\n        # Decline with reason\n        reason_text = \"Not available to take the call\"\n        decline_resp = decline_call(token, call_id, reason=reason_text)\n        assert decline_resp.status_code == 200\n\n        # Verify call is marked declined by fetching details\n        call_details = get_call_details(token, call_id)\n        # The PRD does not specify exact declined status or field,\n        # so we check some plausible fields or keys indicating decline.\n        # We'll assert that the call state/status is not \"ringing\" or \"initiated\"\n        # and optionally check the decline reason presence in response.\n        status = call_details.get(\"status\")\n        assert status is not None\n        assert status.lower() in (\"declined\", \"ended\", \"canceled\") or status.lower() not in (\"ringing\", \"initiated\")\n        # Check reason is reflected if available in call details\n        reason_in_details = call_details.get(\"reason\")\n        if reason_in_details is not None:\n            assert reason_text == reason_in_details or reason_text in reason_in_details\n\n        # Decline without reason (optional test)\n        # Initiate another call to test this\n        call_id_2 = initiate_call(token)\n        try:\n            decline_resp2 = decline_call(token, call_id_2)\n            assert decline_resp2.status_code == 200\n            details2 = get_call_details(token, call_id_2)\n            status2 = details2.get(\"status\")\n            assert status2 is not None\n            assert status2.lower() in (\"declined\", \"ended\", \"canceled\") or status2.lower() not in (\"ringing\", \"initiated\")\n        finally:\n            cancel_call(token, call_id_2)\n    finally:\n        if call_id:\n            cancel_call(token, call_id)\n\n\ntest_decline_call_should_mark_call_as_declined_with_reason()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 122, in <module>\n  File \"<string>\", line 84, in test_decline_call_should_mark_call_as_declined_with_reason\n  File \"<string>\", line 38, in initiate_call\nRuntimeError: No available staff to accept calls, cannot initiate call for testing decline\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.067Z",
    "modified": "2025-11-07T04:20:38.203Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "e31a11da-3a8d-4eee-8b60-b4a4e9fad671",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC007-get available staff should return list filtered by org and skills",
    "description": "Test GET /api/v1/staff/availability with optional orgId and skills query parameters to ensure it returns a 200 status with a list of available staff matching the criteria.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Credentials for authentication (should be valid for the test environment)\nAUTH_EMAIL = \"staff@example.com\"\nAUTH_PASSWORD = \"Password123!\"\n\ndef authenticate():\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\"email\": AUTH_EMAIL, \"password\": AUTH_PASSWORD}\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"token\" in data and isinstance(data[\"token\"], str)\n    return data[\"token\"]\n\ndef test_get_available_staff_filtered_by_org_and_skills():\n    token = authenticate()\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Example query parameters for filtering\n    params = {\n        \"orgId\": \"org123\",\n        \"skills\": \"python,webRTC\"\n    }\n\n    url = f\"{BASE_URL}/api/v1/staff/availability\"\n    resp = requests.get(url, headers=headers, params=params, timeout=TIMEOUT)\n    assert resp.status_code == 200, f\"Expected 200 OK, got {resp.status_code}\"\n\n    json_data = resp.json()\n    assert \"staff\" in json_data, \"Response JSON missing 'staff' key\"\n    assert isinstance(json_data[\"staff\"], list), \"'staff' is not a list\"\n\n    # Further validating each staff item contains key info (loosely, since schema is object)\n    for staff_member in json_data[\"staff\"]:\n        assert isinstance(staff_member, dict)\n        # Optionally check for orgId and skills keys in each staff if present\n        if \"orgId\" in staff_member:\n            assert staff_member[\"orgId\"] == params[\"orgId\"], \"Staff orgId does not match filter\"\n        if \"skills\" in staff_member and isinstance(staff_member[\"skills\"], list):\n            # Ensure all requested skills are subset of staff skills\n            requested_skills = set(s.strip().lower() for s in params[\"skills\"].split(\",\"))\n            staff_skills = set(skill.lower() for skill in staff_member[\"skills\"])\n            assert requested_skills.issubset(staff_skills), \"Staff skills do not match filter\"\n\ntest_get_available_staff_filtered_by_org_and_skills()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.073Z",
    "modified": "2025-11-07T04:20:36.958Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "2372f7db-cc64-4924-8e3c-21381a4a6aa6",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC008-set staff availability should update status and skills",
    "description": "Verify POST /api/v1/staff/availability updates the staff member's availability status and skills, returning 200 status on success.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nSTAFF_AVAILABILITY_URL = f\"{BASE_URL}/api/v1/staff/availability\"\n\nEMAIL = \"staff@example.com\"\nPASSWORD = \"StrongPassword123!\"\n\ndef test_set_staff_availability_updates_status_and_skills():\n    session = requests.Session()\n    try:\n        # Authenticate to obtain JWT token\n        login_payload = {\n            \"email\": EMAIL,\n            \"password\": PASSWORD\n        }\n        login_resp = session.post(LOGIN_URL, json=login_payload, timeout=30)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"JWT token missing in login response\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Prepare payload for availability update\n        availability_payload = {\n            \"status\": \"available\",\n            \"skills\": [\"voice recognition\", \"call management\", \"webrtc\"]\n        }\n\n        # Post staff availability update\n        update_resp = session.post(\n            STAFF_AVAILABILITY_URL,\n            json=availability_payload,\n            headers=headers,\n            timeout=30\n        )\n        assert update_resp.status_code == 200, f\"Failed to update availability: {update_resp.text}\"\n\n        # Optionally, confirm update via get available staff filtered by these skills\n        params = {\n            \"skills\": \",\".join(availability_payload[\"skills\"])\n        }\n        get_resp = session.get(STAFF_AVAILABILITY_URL, headers=headers, params=params, timeout=30)\n        assert get_resp.status_code == 200, f\"Failed to get available staff: {get_resp.text}\"\n        staff_data = get_resp.json()\n        assert \"staff\" in staff_data and isinstance(staff_data[\"staff\"], list), \"Invalid staff data response\"\n\n        # Verify that this staff member appears in the filtered list by checking skills and status\n        # Since no staff ID or user details are exposed in PRD, verify presence of at least one staff member with matching skills\n        found = False\n        for staff_member in staff_data[\"staff\"]:\n            member_skills = staff_member.get(\"skills\") or staff_member.get(\"skill\") or []\n            member_status = staff_member.get(\"status\")\n            # Match if any skill matches and status equals updated status\n            if (isinstance(member_skills, list) and\n                any(skill in member_skills for skill in availability_payload[\"skills\"]) and\n                member_status == availability_payload[\"status\"]):\n                found = True\n                break\n        assert found, \"Updated staff availability not reflected in available staff list\"\n\n    finally:\n        # Cleanup: reset staff availability to offline and clear skills if possible\n        if 'headers' in locals():\n            cleanup_payload = {\n                \"status\": \"offline\",\n                \"skills\": []\n            }\n            try:\n                session.post(STAFF_AVAILABILITY_URL, json=cleanup_payload, headers=headers, timeout=30)\n            except Exception:\n                pass\n\ntest_set_staff_availability_updates_status_and_skills()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 19, in test_set_staff_availability_updates_status_and_skills\nAssertionError: Login failed: Too many login attempts\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.078Z",
    "modified": "2025-11-07T04:20:41.884Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "3b3d7eb2-3002-4066-b792-31681c947a5b",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC009-get notifications should return all notifications",
    "description": "Test GET /api/notifications to ensure it returns a 200 status with a list of all notifications for the authenticated user.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nNOTIFICATIONS_URL = f\"{BASE_URL}/api/notifications\"\nTIMEOUT = 30\n\n# Provide valid credentials for authentication\nTEST_EMAIL = \"testuser@example.com\"\nTEST_PASSWORD = \"testpassword\"\n\ndef test_get_notifications_should_return_all_notifications():\n    try:\n        # Authenticate to get JWT token\n        login_payload = {\n            \"email\": TEST_EMAIL,\n            \"password\": TEST_PASSWORD\n        }\n        login_response = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status {login_response.status_code}\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\")\n        assert token, \"JWT token not found in login response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # Call GET /api/notifications to get all notifications\n        notifications_response = requests.get(NOTIFICATIONS_URL, headers=headers, timeout=TIMEOUT)\n        assert notifications_response.status_code == 200, f\"Expected status 200, got {notifications_response.status_code}\"\n\n        # The response should be a JSON containing a list or array of notifications\n        notifications_data = notifications_response.json()\n\n        # Assert that the notifications_data is a list or has notifications property as list\n        # Since PRD is not explicit on the exact structure, we allow both possibilities:\n        if isinstance(notifications_data, dict):\n            # Common pattern: the notifications list might be under a key\n            notifications_list = None\n            for key in [\"notifications\", \"data\", \"items\", \"list\"]:\n                if key in notifications_data and isinstance(notifications_data[key], list):\n                    notifications_list = notifications_data[key]\n                    break\n            if notifications_list is None:\n                # fallback to all values collected as list items only if the dict contains only list(s)\n                notifications_list = []\n                for v in notifications_data.values():\n                    if isinstance(v, list):\n                        notifications_list = v\n                        break\n            assert notifications_list is not None, \"No list of notifications found in response\"\n            # Further assert that each notification in the list is a dict (object)\n            for notif in notifications_list:\n                assert isinstance(notif, dict), \"Notification item is not an object\"\n        else:\n            # If the response is directly a list\n            assert isinstance(notifications_data, list), \"Response is not a list or object containing a list\"\n            for notif in notifications_data:\n                assert isinstance(notif, dict), \"Notification item is not an object\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_get_notifications_should_return_all_notifications()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 20, in test_get_notifications_should_return_all_notifications\nAssertionError: Login failed with status 429\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.084Z",
    "modified": "2025-11-07T04:20:41.219Z"
  },
  {
    "projectId": "05a42007-6d48-4823-818d-129bb803bd7e",
    "testId": "76c80981-705a-4824-92a8-5348072b3ca4",
    "userId": "a4888448-c0e1-70fd-fe87-9d6c49ce5080",
    "title": "TC010-mark notification as read should update notification status",
    "description": "Verify PATCH /api/notifications/{id}/read marks the specified notification as read and returns a 200 status.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Replace these with valid credentials for authentication\nTEST_USER_EMAIL = \"testuser@example.com\"\nTEST_USER_PASSWORD = \"testpassword\"\n\ndef authenticate():\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\n        \"email\": TEST_USER_EMAIL,\n        \"password\": TEST_USER_PASSWORD\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"token\" in data and data[\"token\"], \"No token in login response\"\n    return data[\"token\"]\n\ndef create_notification(headers):\n    url = f\"{BASE_URL}/api/notifications\"\n    resp = requests.post(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    # Expect at least an id or some identifier\n    # Assuming API returns notification object containing id\n    # If response is empty or returns just status, fail the test\n    if isinstance(data, dict) and \"id\" in data:\n        return data[\"id\"]\n    else:\n        # Try if data is a list or fallback to get from headers or raise error\n        raise AssertionError(\"Notification creation did not return an id\")\n\ndef delete_notification(notification_id, headers):\n    url = f\"{BASE_URL}/api/notifications/{notification_id}\"\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    assert resp.status_code == 200, f\"Failed to delete notification {notification_id}\"\n\ndef test_mark_notification_as_read_should_update_notification_status():\n    token = authenticate()\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    notification_id = None\n\n    # Create a new notification to ensure test isolation\n    try:\n        notification_id = create_notification(headers)\n\n        assert notification_id, \"Created notification id is invalid\"\n\n        url = f\"{BASE_URL}/api/notifications/{notification_id}/read\"\n        resp = requests.patch(url, headers=headers, timeout=TIMEOUT)\n\n        assert resp.status_code == 200, f\"Expected 200 status, got {resp.status_code}\"\n        \n        # Optionally verify the notification is marked as read by fetching notifications or unread endpoint\n        # Let's get unread notifications to check the notification is no longer present\n        unread_url = f\"{BASE_URL}/api/notifications/unread\"\n        unread_resp = requests.get(unread_url, headers=headers, timeout=TIMEOUT)\n        unread_resp.raise_for_status()\n        unread_notifications = unread_resp.json()\n        assert isinstance(unread_notifications, list) or isinstance(unread_notifications, dict), \"Unread notifications response invalid\"\n        # The unread notifications may be a list or dict with 'notifications' - check if notification id is absent\n        # Try to find notification_id in unread notifications, if found fail\n        if isinstance(unread_notifications, list):\n            assert notification_id not in [n.get(\"id\") for n in unread_notifications if \"id\" in n], \"Notification still unread after marking as read\"\n        elif isinstance(unread_notifications, dict):\n            # If the structure contains a list under a key (e.g. 'notifications' or 'data'), try known keys\n            candidates = []\n            for key in (\"notifications\", \"data\", \"items\", \"unread\"):\n                if key in unread_notifications and isinstance(unread_notifications[key], list):\n                    candidates = unread_notifications[key]\n                    break\n            if candidates:\n                assert notification_id not in [n.get(\"id\") for n in candidates if \"id\" in n], \"Notification still unread after marking as read\"\n\n    finally:\n        if notification_id:\n            delete_notification(notification_id, headers)\n\ntest_mark_notification_as_read_should_update_notification_status()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 43, in test_mark_notification_as_read_should_update_notification_status\n  File \"<string>\", line 17, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 429 Client Error: Too Many Requests for url: http://localhost:8080/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-07T04:19:55.089Z",
    "modified": "2025-11-07T04:20:42.035Z"
  }
]
